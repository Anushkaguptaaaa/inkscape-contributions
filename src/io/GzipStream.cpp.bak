/**
 * Zlib-enabled input and output streams
 *
 * This is a thin wrapper of 'gzstreams', to
 * allow our customizations.
 *
 * Authors:
 *   Bob Jamison <rjamison@titan.com>
 *
 * Copyright (C) 2004 Inkscape.org
 *
 * Released under GNU GPL, read the file 'COPYING' for more information
 */
#include "GzipStream.h"
#include  <zlib.h>
#include  <zutil.h>

namespace Inkscape
{
namespace IO
{

//#########################################################################
//# G Z I P    I N P U T    S T R E A M
//#########################################################################


/**
 *
 */ 
GzipInputStream::GzipInputStream(InputStream &sourceStream)
                    : BasicInputStream(sourceStream)
{
    d_stream.zalloc    = (alloc_func)0;
    d_stream.zfree     = (free_func)0;
    d_stream.opaque    = (voidpf)0;
    outputBufPos       = 0;
    outputBufLen       = 0;
    d_stream.avail_out = 0;
    d_stream.avail_in  = 0;
    
    zerrNr = inflateInit(&d_stream);

    totalIn         = 0;
    totalOut        = 0;
    crc = crc32(0L, Z_NULL, 0);
    
    //Magic
    uInt val = source.get();
    printf("val:%x\n", val);
    val = source.get();
    printf("val:%x\n", val);

    //Method
    val = source.get();

    //time
    val = source.get();
    val = source.get();
    val = source.get();
    val = source.get();

    //flags
    val = source.get();
    //xflags
    val = source.get();
    //OS
    val = source.get();
    
    done = false;
    
}

/**
 *
 */ 
GzipInputStream::~GzipInputStream()
{
    close();
}

/**
 * Returns the number of bytes that can be read (or skipped over) from
 * this input stream without blocking by the next caller of a method for
 * this input stream.
 */ 
int GzipInputStream::available()
{
    if (closed)
        return 0;
    return d_stream.avail_out - outputBufPos;
}

    
/**
 *  Closes this input stream and releases any system resources
 *  associated with the stream.
 */ 
void GzipInputStream::close()
{
    if (closed)
        return;
    zerrNr = inflateEnd(&d_stream);
}
    
/**
 * Reads the next byte of data from the input stream.  -1 if EOF
 */ 
int GzipInputStream::get()
{
    if (closed || done)
        return -1;
    //Still data in the output buffer?
    printf("outputBufPos:%d outputBufLen:%d\n", outputBufPos, outputBufLen);
    if (outputBufPos < outputBufLen)
        {
        int ch = (int) outputBuf[outputBufPos++];
        totalOut++;
        return ch;
        }
        
    //Is the input to Zlib empty?
    printf("d_stream.avail_in:%d\n", d_stream.avail_in);
    if (d_stream.avail_in < 1)
        {
        for (inputBufLen=0 ; inputBufLen<GZIP_INBUFSIZE ; inputBufLen++)
            {
            int ch = source.get();
            if (ch<0)
                {
                done = true;
                break;
                }
            inputBuf[inputBufLen] = (Byte)ch;
            totalIn++;
            }
        d_stream.next_in   = inputBuf;
        d_stream.avail_in  = inputBufLen;
        d_stream.next_out  = outputBuf;
        d_stream.avail_out = GZIP_OUTBUFSIZE;
        outputBufPos       = 0;
        }

    outputBufLen = 0;
    
    //Try to decompress everything
    printf("d_stream.avail_out:%d\n", d_stream.avail_out);
    while (d_stream.avail_in > 0 && d_stream.avail_out > 0)
        {
        if (done)
            zerrNr = inflate(&d_stream, Z_FINISH);
        else
            zerrNr = inflate(&d_stream, Z_SYNC_FLUSH);
        if (zerrNr == Z_STREAM_END)
            break;
        outputBufLen = GZIP_OUTBUFSIZE - d_stream.avail_out;
        crc = crc32(crc, (const Bytef *)outputBuf, outputBufLen);
        }

    printf("d_stream.avail_out:%d\n", d_stream.avail_out);

    //Still nothing? Then we are done
    if (outputBufLen < 0)
        {
        return -1;
        }

    int ch = (int)outputBuf[outputBufPos++];
    return ch;
}
   



//#########################################################################
//# G Z I P   O U T P U T    S T R E A M
//#########################################################################

/**
 *
 */ 
GzipOutputStream::GzipOutputStream(OutputStream &destinationStream)
                     : BasicOutputStream(destinationStream)
{

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree  = (free_func)0;
    c_stream.opaque = (voidpf)0;

    zerrNr = deflateInit(&c_stream,  Z_DEFAULT_COMPRESSION);

    inputBufPos     = 0;

    totalIn         = 0;
    totalOut        = 0;
    crc = crc32(0L, Z_NULL, 0);

    //Gzip header
    destination.put(0x1f);
    destination.put(0x8b);

    //Say it is compressed
    destination.put(Z_DEFLATED);

    //flags
    destination.put(0);

    //time
    destination.put(0);
    destination.put(0);
    destination.put(0);
    destination.put(0);

    //xflags
    destination.put(0);

    //OS code - from zutil.h
    destination.put(OS_CODE);

}

/**
 *
 */ 
GzipOutputStream::~GzipOutputStream()
{
    close();
}

/**
 * Closes this output stream and releases any system resources
 * associated with this stream.
 */ 
void GzipOutputStream::close()
{
    if (closed)
        return;

    flush();
    flushFinal();
    
    zerrNr = deflateEnd (&c_stream);
    printf("end:%d\n", zerrNr);

    destination.close();
    closed = true;
}
    
/**
 *  Flushes this output stream and forces any buffered output
 *  bytes to be written out.
 */ 
void GzipOutputStream::flush()
{
    if (closed)
        return;
        
    if (inputBufPos < 1)
        {
        destination.flush();
        return;
        }

    crc = crc32(crc, (const Bytef *)inputBuf, inputBufPos);

    c_stream.next_in   = inputBuf;
    c_stream.avail_in  = inputBufPos;

    //Read the entire input buffer
    while (c_stream.avail_in > 0)
        {
        c_stream.next_out  = outputBuf;
        c_stream.avail_out = GZIP_OUTBUFSIZE;
        zerrNr = deflate(&c_stream, Z_NO_FLUSH);
        int nrBytes = GZIP_OUTBUFSIZE - c_stream.avail_out;
        printf("zerrno:%d out:%d\n", zerrNr, nrBytes);
        for (int i=0 ; i<nrBytes ; i++)
           {
           totalOut++;
           destination.put((int) outputBuf[i]);
           }
        }
        
    //Reset for next put()
    inputBufPos = 0;
    destination.flush();
}


/**
 *  Flushes this output stream and forces any buffered output
 *  bytes to be written out.
 */ 
void GzipOutputStream::flushFinal()
{
    if (closed)
        return;
        
    /* Finish the stream */

    c_stream.next_in   = inputBuf;
    c_stream.avail_in  = 0;
    for (;;)
        {
        c_stream.next_out  = outputBuf;
        c_stream.avail_out = GZIP_OUTBUFSIZE;
        zerrNr = deflate(&c_stream, Z_FINISH);
        int nrBytes = GZIP_OUTBUFSIZE - c_stream.avail_out;
        printf("zerrno3:%d out:%d\n", zerrNr, nrBytes);
        if (zerrNr == Z_STREAM_END)
            break;
        for (int i=0 ; i<nrBytes ; i++)
           {
           totalOut++;
           destination.put((int) outputBuf[i]);
           }
       }
    //# Send the CRC
    uLong outlong = crc;
    for (int n = 0; n < 4; n++)
        {
        destination.put((int)(outlong & 0xff));
        outlong >>= 8;
        }
    //# send the file length
    outlong = totalIn & 0xffffffffL;
    for (int n = 0; n < 4; n++)
        {
        destination.put((int)(outlong & 0xff));
        outlong >>= 8;
        }

    printf("totalIn: %ld / totalOut:%ld\n", totalIn, totalOut);
    destination.flush();
}
    
/**
 * Writes the specified byte to this output stream.
 */ 
void GzipOutputStream::put(int ch)
{
    if (closed)
        {
        //probably throw an exception here
        return;
        }


    //Add char to buffer
    inputBuf[inputBufPos++] = (Byte) ch;
    totalIn++;

    //Are we full?
    if (inputBufPos >= GZIP_INBUFSIZE)
        flush();
}



} // namespace IO
} // namespace Inkscape


//#########################################################################
//# E N D    O F    F I L E
//#########################################################################
